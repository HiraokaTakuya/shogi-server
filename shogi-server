#! /usr/bin/env ruby
## -*-Ruby-*- $RCSfile$ $Revision$ $Name$

## Copyright (C) 2004 nanami@2ch
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Max_Write_Queue_Size = 1000
Max_Identifier_Length = 32
Default_Timeout = 60            # for single socket operation

Default_Game_Name = "default:1500:0"

One_Time = 10
Least_Time_Per_Move = 1
Login_Time = 300                # time for LOGIN

Release = "$Name$".split[1].sub(/\A[^\d]*/, '').gsub(/_/, '.')
Release.concat("-") if (Release == "")
Revision = "$Revision$".gsub(/[^\.\d]/, '')

STDOUT.sync = true
STDERR.sync = true

require 'getoptlong'
require 'thread'
require 'timeout'
require 'socket'

TCPSocket.do_not_reverse_lookup = true


class TCPSocket
  def gets_timeout(t = Default_Timeout)
    begin
      timeout(t) do
        return self.gets
      end
    rescue TimeoutError
      return nil
    rescue
      return nil
    end
  end
  def gets_safe(t = nil)
    if (t && t > 0)
      begin
        timeout(t) do
          return self.gets
        end
      rescue TimeoutError
        return :timeout
      rescue
        return nil
      end
    else
      begin
        return self.gets
      rescue
        return nil
      end
    end
  end
  def write_safe(str)
    begin
      return self.write(str)
    rescue
      return nil
    end
  end
end


class League
  def initialize
    @games = Hash::new
    @players = Hash::new
    @event = nil
  end
  attr_accessor :players, :games, :event

  def add(player)
    @players[player.name] = player
  end
  def delete(player)
    @players.delete(player.name)
  end
  def get_player(status, game_name, sente, searcher=nil)
    @players.each do |name, player|
      if ((player.status == status) &&
          (player.game_name == game_name) &&
          ((player.sente == nil) || (player.sente == sente)) &&
          ((searcher == nil) || (player != searcher)))
        return player
      end
    end
    return nil
  end
end

class Player
  def initialize(str, socket)
    @name = nil
    @password = nil
    @socket = socket
    @status = "connected"        # game_waiting -> agree_waiting -> start_waiting -> game -> finished

    @protocol = nil             # CSA or x1
    @eol = "\m"                 # favorite eol code
    @game = nil
    @game_name = ""
    @mytime = 0                 # set in start method also
    @sente = nil
    @writer_thread = nil
    @main_thread = nil
    @write_queue = Queue::new
    login(str)
  end

  attr_accessor :name, :password, :socket, :status
  attr_accessor :protocol, :eol, :game, :mytime, :game_name, :sente
  attr_accessor :main_thread, :writer_thread, :write_queue
  def kill
    finish
    Thread::kill(@main_thread) if @main_thread
  end

  def finish
    if (@status != "finished")
      @status = "finished"
      log_message(sprintf("user %s finish", @name))    
      Thread::kill(@writer_thread) if @writer_thread
      begin
        @socket.close if (! @socket.closed?)
      rescue
        log_message(sprintf("user %s finish failed", @name))    
      end
    end
  end

  def write_safe(str)
    @write_queue.push(str.gsub(/[\r\n]+/, @eol))
  end

  def writer
    while (str = @write_queue.pop)
      @socket.write_safe(str)
    end
  end

  def to_s
    if ((status == "game_waiting") ||
        (status == "agree_waiting") ||
        (status == "game"))
      if (@sente)
        return sprintf("%s %s %s %s +", @name, @protocol, @status, @game_name)
      elsif (@sente == false)
        return sprintf("%s %s %s %s -", @name, @protocol, @status, @game_name)
      elsif (@sente == nil)
        return sprintf("%s %s %s %s +-", @name, @protocol, @status, @game_name)
      end
    else
      return sprintf("%s %s %s", @name, @protocol, @status)
    end
  end

  def write_help
    @socket.write_safe('##[HELP] available commands "%%WHO", "%%CHAT str", "%%GAME game_name +", "%%GAME game_name -"')
  end

  def login(str)
    str =~ /([\r\n]*)$/
    @eol = $1
    str.chomp!
    (login, @name, @password, ext) = str.split
    if (ext)
      @protocol = "x1"
    else
      @protocol = "CSA"
    end
    @main_thread = Thread::current
    @writer_thread = Thread::start do
      writer()
    end
  end
    
  def run
    write_safe(sprintf("LOGIN:%s OK\n", @name))
    if (@protocol != "CSA")
      log_message(sprintf("user %s run in %s mode", @name, @protocol))
      write_safe(sprintf("##[LOGIN] +OK %s\n", @protocol))
    else
      log_message(sprintf("user %s run in CSA mode", @name))
      csa_1st_str = "%%GAME #{Default_Game_Name} +-"
    end
    
    while (csa_1st_str || (str = @socket.gets_safe(Default_Timeout)))
      begin
        $mutex.lock
        if (csa_1st_str)
          str = csa_1st_str
          csa_1st_str = nil
        end
        if (@write_queue.size > Max_Write_Queue_Size)
          log_warning(sprintf("write_queue of %s is %d", @name, @write_queue.size))
	  return
        end

        if (@status == "finished")
          return
        end
        str.chomp! if (str.class == String)
        case str
        when /^[\+\-%][^%]/, :timeout
          if (@status == "game")
            s = @game.handle_one_move(str, self)
            return if (s && @protocol == "CSA")
          end
        when /^REJECT/
          if (@status == "agree_waiting")
            @game.reject(@name)
            return if (@protocol == "CSA")
          else
            write_safe(sprintf("##[ERROR] you are in %s status. AGREE is valid in agree_waiting status\n", @status))
          end
        when /^AGREE/
          if (@status == "agree_waiting")
            @status = "start_waiting"
            if ((@game.sente.status == "start_waiting") &&
                (@game.gote.status == "start_waiting"))
              @game.start
              @game.sente.status = "game"
              @game.gote.status = "game"
            end
          else
            write_safe(sprintf("##[ERROR] you are in %s status. AGREE is valid in agree_waiting status\n", @status))
          end
        when /^%%SHOW\s+(\S+)/
          game_id = $1
          if (LEAGUE.games[game_id])
            write_safe(LEAGUE.games[game_id].show.gsub(/^/, '##[SHOW] '))
          end
          write_safe("##[SHOW] +OK\n")
        when /^%%MONITORON\s+(\S+)/
          game_id = $1
          if (LEAGUE.games[game_id])
            LEAGUE.games[game_id].monitoron(self)
            write_safe(LEAGUE.games[game_id].show.gsub(/^/, "##[MONITOR][#{game_id}] "))
            write_safe("##[MONITOR][#{game_id}] +OK\n")
          end
        when /^%%MONITOROFF\s+(\S+)/
          game_id = $1
          if (LEAGUE.games[game_id])
            LEAGUE.games[game_id].monitoroff(self)
          end
        when /^%%HELP/
          write_help
        when /^%%GAME\s+(\S+)\s+([\+\-]+)$/
          game_name = $1
          sente_str = $2
          if (! good_game_name?(game_name))
            write_safe(sprintf("##[ERROR] bad game name\n"))
          elsif ((@status == "connected") || (@status == "game_waiting"))
            @status = "game_waiting"
          else
            write_safe(sprintf("##[ERROR] you are in %s status. GAME is valid in connected or game_waiting status\n", @status))
          end
          @status = "game_waiting"
          @game_name = $1
          if (sente_str == "+")
            @sente = true
            rival_sente = false
          elsif (sente_str == "-")
            @sente = false
            rival_sente = true
          else
            @sente = nil
            rival_sente = nil
          end
          rival = LEAGUE.get_player("game_waiting", @game_name, rival_sente, self)
          rival = LEAGUE.get_player("game_waiting", @game_name, nil, self) if (! rival)
          if (rival)
            if (@sente == nil)
              if (rand(2) == 0)
                @sente = true
                rival_sente = false
              else
                @sente = false
                rival_sente = true
              end
            elsif (rival_sente == nil)
              if (@sente)
                rival_sente = false
              else
                rival_sente = true
              end
            end
            rival.sente = rival_sente
            Game::new(@game_name, self, rival)
            self.status = "agree_waiting"
            rival.status = "agree_waiting"
          end
        when /^%%CHAT\s+(.+)/
          message = $1
          LEAGUE.players.each do |name, player|
            if (player.protocol != "CSA")
              s = player.write_safe(sprintf("##[CHAT][%s] %s\n", @name, message)) 
              player.status = "zombie" if (! s)
            end
          end
        when /^%%LIST/
          buf = Array::new
          LEAGUE.games.each do |id, game|
            buf.push(sprintf("##[LIST] %s\n", id))
          end
          buf.push("##[LIST] +OK\n")
          write_safe(buf.join)
        when /^%%WHO/
          buf = Array::new
          LEAGUE.players.each do |name, player|
            buf.push(sprintf("##[WHO] %s\n", player.to_s))
          end
          buf.push("##[WHO] +OK\n")
          write_safe(buf.join)
        when /^LOGOUT/
          @status = "connected"
          write_safe("LOGOUT:completed\n")
          return
        when /^\s*$/
          ## ignore null string
        else
          write_safe(sprintf("##[ERROR] unknown command %s\n", str))
        end
      ensure
        $mutex.unlock
      end
    end                         # enf of while
  end
end

class Piece
  PROMOTE = {"FU" => "TO", "KY" => "NY", "KE" => "NK", "GI" => "NG", "KA" => "UM", "HI" => "RY"}
  def initialize(name, sente)
    @name = name
    @sente = sente
    @promoted = false
  end
  attr_accessor :name, :promoted, :sente

  def promoted_name
    PROMOTE[name]
  end

  def to_s
    if (@sente)
      sg = "+"
    else
      sg = "-"
    end
    if (@promoted)
      n = PROMOTE[@name]
    else
      n = @name
    end
    return sg + n
  end
end



class Board
  def initialize
    @sente_hands = Array::new
    @gote_hands = Array::new
    @history = Hash::new
    @array = [[], [], [], [], [], [], [], [], [], []]
  end
  attr_accessor :array, :sente_hands, :gote_hands, :history

  def initial
    @array[1][1] = Piece::new("KY", false)
    @array[2][1] = Piece::new("KE", false)
    @array[3][1] = Piece::new("GI", false)
    @array[4][1] = Piece::new("KI", false)
    @array[5][1] = Piece::new("OU", false)
    @array[6][1] = Piece::new("KI", false)
    @array[7][1] = Piece::new("GI", false)
    @array[8][1] = Piece::new("KE", false)
    @array[9][1] = Piece::new("KY", false)
    @array[2][2] = Piece::new("KA", false)
    @array[8][2] = Piece::new("HI", false)
    @array[1][3] = Piece::new("FU", false)
    @array[2][3] = Piece::new("FU", false)
    @array[3][3] = Piece::new("FU", false)
    @array[4][3] = Piece::new("FU", false)
    @array[5][3] = Piece::new("FU", false)
    @array[6][3] = Piece::new("FU", false)
    @array[7][3] = Piece::new("FU", false)
    @array[8][3] = Piece::new("FU", false)
    @array[9][3] = Piece::new("FU", false)

    @array[1][9] = Piece::new("KY", true)
    @array[2][9] = Piece::new("KE", true)
    @array[3][9] = Piece::new("GI", true)
    @array[4][9] = Piece::new("KI", true)
    @array[5][9] = Piece::new("OU", true)
    @array[6][9] = Piece::new("KI", true)
    @array[7][9] = Piece::new("GI", true)
    @array[8][9] = Piece::new("KE", true)
    @array[9][9] = Piece::new("KY", true)
    @array[2][8] = Piece::new("HI", true)
    @array[8][8] = Piece::new("KA", true)
    @array[1][7] = Piece::new("FU", true)
    @array[2][7] = Piece::new("FU", true)
    @array[3][7] = Piece::new("FU", true)
    @array[4][7] = Piece::new("FU", true)
    @array[5][7] = Piece::new("FU", true)
    @array[6][7] = Piece::new("FU", true)
    @array[7][7] = Piece::new("FU", true)
    @array[8][7] = Piece::new("FU", true)
    @array[9][7] = Piece::new("FU", true)
  end

  def have_piece?(hands, name)
    p = hands.find { |i|
      i.name == name
    }
    return p
  end

  def get_piece_from_hands(hands, name)
    p = hands.find { |i|
      i.name == name
    }
    if (p)
      hands.delete(p)
    end
    return p
  end

  def handle_one_move(str)
    if (str =~ /^([\+\-])(\d)(\d)(\d)(\d)([A-Z]{2})/)
      p = $1
      x0 = $2.to_i
      y0 = $3.to_i
      x1 = $4.to_i
      y1 = $5.to_i
      name = $6
    elsif (str =~ /^%KACHI/)
      return :kachi
    elsif (str =~ /^%TORYO/)
      return :toryo
    else
      return :illegal
    end
    
    if (((x0 == 0) || (y0 == 0)) && # source is not from hand
        ((x0 != 0) || (y0 != 0)))
      return :illegal
    elsif ((x1 == 0) || (y1 == 0)) # destination is out of board
      return :illegal
    end
    
    if (p == "+")
      sente = true
      hands = @sente_hands
    else
      sente = false
      hands = @gote_hands
    end
    
    ## source check
    if ((x0 == 0) && (y0 == 0))
      return :illegal if (! have_piece?(hands, name))
    elsif (! @array[x0][y0])
      return :illegal           # no piece
    elsif (@array[x0][y0].sente != sente)
      return :illegal           # this is not mine
    elsif (@array[x0][y0].name != name)
      return :illegal if (@array[x0][y0].promoted_name != name) # can't promote
    end
    
    ## destination check
    if (@array[x1][y1] &&
        (@array[x1][y1].sente == sente)) # can't capture mine
      return :illegal
    elsif ((x0 == 0) && (y0 == 0) && @array[x1][y1])
      return :illegal           # can't put on existing piece
    end

    if ((x0 == 0) && (y0 == 0))
      p = get_piece_from_hands(hands, name)
      @array[x1][y1] = p
      p.sente = sente
      p.promoted = false
    else
      if (@array[x0][y0].name != name) # promoted ?
        @array[x0][y0].promoted = true
      end
      if (@array[x1][y1])
        if (@array[x1][y1].name == "OU")
          return :outori        # return board update
        end
        hands.push(@array[x1][y1])
        hands.sort! {|a, b|
          a.name <=> b.name
        }
      end
      @array[x1][y1] = @array[x0][y0]
      @array[x0][y0] = nil
    end

    ## sennichite check
    str = to_s
    @history[str] = (@history[str] || 0) + 1
    if (@history[str] >= 4)
      return :sennichite
    end

    return :normal             # legal move
  end

  def to_s
    a = Array::new
    y = 1
    while (y <= 9)
      a.push(sprintf("P%d", y))
      x = 9
      while (x >= 1)
        piece = @array[x][y]
        if (piece)
          s = piece.to_s
        else
          s = " * "
        end
        a.push(s)
        x = x - 1
      end
      a.push(sprintf("\n"))
      y = y + 1
    end
    if (! sente_hands.empty?)
      a.push("P+")
      sente_hands.each do |p|
        a.push("00" + p.name)
      end
      a.push("\n")
    end
    if (! gote_hands.empty?)
      a.push("P-")
      gote_hands.each do |p|
        a.push("00" + p.name)
      end
      a.push("\n")
    end
    a.push("+\n")
    return a.join
  end
end

class Game
  def initialize(game_name, player0, player1)
    @monitors = Array::new
    @game_name = game_name
    if (@game_name =~ /:(\d+):(\d+)/)
      @total_time = $1.to_i
      @byoyomi = $2.to_i
    end

    if (player0.sente)
      @sente = player0
      @gote = player1
    else
      @sente = player1
      @gote = player0
    end
    @current_player = @sente
    @next_player = @gote

    @sente.game = self
    @gote.game = self

    @last_move = ""
    @current_turn = 0

    @sente.status = "agree_waiting"
    @gote.status = "agree_waiting"
    @id = sprintf("%s+%s+%s+%s+%s", 
                  LEAGUE.event, @game_name, @sente.name, @gote.name,
                  Time::new.strftime("%Y%m%d%H%M%S"))

    LEAGUE.games[@id] = self


    log_message(sprintf("game created %s %s %s", game_name, sente.name, gote.name))

    @logfile = @id + ".csa"
    @board = Board::new
    @board.initial
    @start_time = nil
    @fh = nil

    propose
  end
  attr_accessor :game_name, :total_time, :byoyomi, :sente, :gote, :id, :board, :current_player, :next_player, :fh, :monitors
  attr_accessor :last_move, :current_turn

  def monitoron(monitor)
    @monitors.delete(monitor)
    @monitors.push(monitor)
  end

  def monitoroff(monitor)
    @monitors.delete(monitor)
  end

  def reject(rejector)
    @sente.write_safe(sprintf("REJECT:%s by %s\n", @id, rejector))
    @gote.write_safe(sprintf("REJECT:%s by %s\n", @id, rejector))
    finish
  end

  def kill(killer)
    if ((@sente.status == "agree_waiting") || (@sente.status == "start_waiting"))
      reject(killer.name)
    elsif (@current_player == killer)
      abnormal_lose()
      finish
    end
  end

  def finish
    log_message(sprintf("game finished %s %s %s", game_name, sente.name, gote.name))
    @fh.printf("'$END_TIME:%s\n", Time::new.strftime("%Y/%m/%d %H:%M:%S"))    
    @fh.close

    @sente.game = nil
    @gote.game = nil
    @sente.status = "connected"
    @gote.status = "connected"

    if (@current_player.protocol == "CSA")
      @current_player.finish
    end
    if (@next_player.protocol == "CSA")
      @next_player.finish
    end
    @monitors = Array::new
    @sente = nil
    @gote = nil
    @current_player = nil
    @next_player = nil
    LEAGUE.games.delete(@id)
  end

  def handle_one_move(str, player)
    finish_flag = true
    if (@current_player == player)
      @end_time = Time::new
      t = (@end_time - @start_time).ceil
      t = Least_Time_Per_Move if (t < Least_Time_Per_Move)
      
      move_status = nil
      if ((@current_player.mytime - t <= 0) && (@total_time > 0))
        status = :timeout
      elsif (str == :timeout)
        return false            # time isn't expired. players aren't swapped. continue game
      else
        begin
          move_status = @board.handle_one_move(str)
        rescue
          log_error("handle_one_move raise exception for #{str}")
          move_status = :illegal
        end
        if (move_status == :illegal)
          @fh.printf("'ILLEGAL_MOVE(%s)\n", str)
        else
          if ((move_status == :normal) || (move_status == :outori) || (move_status == :sennichite))
            @sente.write_safe(sprintf("%s,T%d\n", str, t))
            @gote.write_safe(sprintf("%s,T%d\n", str, t))
            @fh.printf("%s\nT%d\n", str, t)
            @last_move = sprintf("%s,T%d", str, t)
            @current_turn = @current_turn + 1
          end
          @monitors.each do |monitor|
            monitor.write_safe(show.gsub(/^/, "##[MONITOR][#{@id}] "))
            monitor.write_safe(sprintf("##[MONITOR][%s] +OK\n", @id))
          end
        end
      end

      if (@current_player.mytime - t < @byoyomi)
        @current_player.mytime = @byoyomi
      else
        @current_player.mytime = @current_player.mytime - t
      end

      if (@next_player.status != "game") # rival is logout or disconnected
        abnormal_win()
      elsif (status == :timeout)
        timeout_lose()
      elsif (move_status == :illegal)
        illegal_lose()
      elsif (move_status == :kachi)
        kachi_win()
      elsif (move_status == :toryo)
        toryo_lose()
      elsif (move_status == :outori)
        outori_win()
      elsif (move_status == :sennichite)
        sennichite_draw()
      else
        finish_flag = false
      end
      finish() if finish_flag
      (@current_player, @next_player) = [@next_player, @current_player]
      @start_time = Time::new
      return finish_flag
    end
  end

  def abnormal_win
    @current_player.status = "connected"
    @next_player.status = "connected"
    @current_player.write_safe("%TORYO\n#RESIGN\n#WIN\n")
    @next_player.write_safe("%TORYO\n#RESIGN\n#LOSE\n")
    @fh.printf("%%TORYO\n")
    @fh.printf("'summary:abnormal:%s win:%s lose\n", @current_player.name, @next_player.name)
    @monitors.each do |monitor|
      monitor.write_safe(sprintf("##[MONITOR][%s] %%TORYO\n", @id))
    end
  end

  def abnormal_lose
    @current_player.status = "connected"
    @next_player.status = "connected"
    @current_player.write_safe("%TORYO\n#RESIGN\n#LOSE\n")
    @next_player.write_safe("%TORYO\n#RESIGN\n#WIN\n")
    @fh.printf("%%TORYO\n")
    @fh.printf("'summary:abnormal:%s lose:%s win\n", @current_player.name, @next_player.name)
    @monitors.each do |monitor|
      monitor.write_safe(sprintf("##[MONITOR][%s] %%TORYO\n", @id))
    end
  end

  def sennichite_draw
    @current_player.status = "connected"
    @next_player.status = "connected"
    @current_player.write_safe("#SENNICHITE\n#DRAW\n")
    @next_player.write_safe("#SENNICHITE\n#DRAW\n")
    @fh.printf("'summary:sennichite:%s draw:%s draw\n", @current_player.name, @next_player.name)
    @monitors.each do |monitor|
      monitor.write_safe(sprintf("##[MONITOR][%s] #SENNICHITE\n", @id))
    end
  end

  def illegal_lose
    @current_player.status = "connected"
    @next_player.status = "connected"
    @current_player.write_safe("#ILLEGAL_MOVE\n#LOSE\n")
    @next_player.write_safe("#ILLEGAL_MOVE\n#WIN\n")
    @fh.printf("'summary:illegal move:%s lose:%s win\n", @current_player.name, @next_player.name)
    @monitors.each do |monitor|
      monitor.write_safe(sprintf("##[MONITOR][%s] #ILLEGAL_MOVE\n", @id))
    end
  end

  def timeout_lose
    @current_player.status = "connected"
    @next_player.status = "connected"
    @current_player.write_safe("#TIME_UP\n#LOSE\n")
    @next_player.write_safe("#TIME_UP\n#WIN\n")
    @fh.printf("'summary:time up:%s lose:%s win\n", @current_player.name, @next_player.name)
    @monitors.each do |monitor|
      monitor.write_safe(sprintf("##[MONITOR][%s] #TIME_UP\n", @id))
    end
  end

  def kachi_win
    @current_player.status = "connected"
    @next_player.status = "connected"
    @current_player.write_safe("%KACHI\n#JISHOGI\n#WIN\n")
    @next_player.write_safe("%KACHI\n#JISHOGI\n#LOSE\n")
    @fh.printf("%%KACHI\n")
    @fh.printf("'summary:kachi:%s win:%s lose\n", @current_player.name, @next_player.name)
    @monitors.each do |monitor|
      monitor.write_safe(sprintf("##[MONITOR][%s] %%KACHI\n", @id))
    end
  end

  def toryo_lose
    @current_player.status = "connected"
    @next_player.status = "connected"
    @current_player.write_safe("%TORYO\n#RESIGN\n#LOSE\n")
    @next_player.write_safe("%TORYO\n#RESIGN\n#WIN\n")
    @fh.printf("%%TORYO\n")
    @fh.printf("'summary:toryo:%s lose:%s win\n", @current_player.name, @next_player.name)
    @monitors.each do |monitor|
      monitor.write_safe(sprintf("##[MONITOR][%s] %%TORYO\n", @id))
    end
  end

  def outori_win
    @current_player.status = "connected"
    @next_player.status = "connected"
    @current_player.write_safe("#ILLEGAL_MOVE\n#WIN\n")
    @next_player.write_safe("#ILLEGAL_MOVE\n#LOSE\n")
    @fh.printf("'summary:outori:%s win:%s lose\n", @current_player.name, @next_player.name)
    @monitors.each do |monitor|
      monitor.write_safe(sprintf("##[MONITOR][%s] #ILLEGAL_MOVE\n", @id))
    end
  end

  def start
    log_message(sprintf("game started %s %s %s", game_name, sente.name, gote.name))
    @sente.write_safe(sprintf("START:%s\n", @id))
    @gote.write_safe(sprintf("START:%s\n", @id))
    @sente.mytime = @total_time
    @gote.mytime = @total_time
    @start_time = Time::new
  end

  def propose
    begin
      @fh = open(@logfile, "w")
      @fh.sync = true

      @fh.printf("V2\n")
      @fh.printf("N+%s\n", @sente.name)
      @fh.printf("N-%s\n", @gote.name)
      @fh.printf("$EVENT:%s\n", @id)

      @sente.write_safe(propose_message("+"))
      @gote.write_safe(propose_message("-"))

      @fh.printf("$START_TIME:%s\n", Time::new.strftime("%Y/%m/%d %H:%M:%S"))
      @fh.print <<EOM
P1-KY-KE-GI-KI-OU-KI-GI-KE-KY
P2 * -HI *  *  *  *  * -KA * 
P3-FU-FU-FU-FU-FU-FU-FU-FU-FU
P4 *  *  *  *  *  *  *  *  * 
P5 *  *  *  *  *  *  *  *  * 
P6 *  *  *  *  *  *  *  *  * 
P7+FU+FU+FU+FU+FU+FU+FU+FU+FU
P8 * +KA *  *  *  *  * +HI * 
P9+KY+KE+GI+KI+OU+KI+GI+KE+KY
+
EOM
    end
  end

  def show()
    str0 = <<EOM
BEGIN Game_Summary
Protocol_Version:1.0
Protocol_Mode:Server
Format:Shogi 1.0
Game_ID:#{@id}
Name+:#{@sente.name}
Name-:#{@gote.name}
Rematch_On_Draw:NO
To_Move:+
BEGIN Time
Time_Unit:1sec
Total_Time:#{@total_time}
Byoyomi:#{@byoyomi}
Least_Time_Per_Move:#{Least_Time_Per_Move}
Remaining_Time+:#{@sente.mytime}
Remaining_Time-:#{@gote.mytime}
Last_Move:#{@last_move}
Current_Turn:#{@current_turn}
END Time
BEGIN Position
Jishogi_Declaration:1.1
EOM

    str1 = <<EOM
END Position
END Game_Summary
EOM

    return str0 + @board.to_s + str1
  end

  def propose_message(sg_flag)
    str = <<EOM
BEGIN Game_Summary
Protocol_Version:1.0
Protocol_Mode:Server
Format:Shogi 1.0
Game_ID:#{@id}
Name+:#{@sente.name}
Name-:#{@gote.name}
Your_Turn:#{sg_flag}
Rematch_On_Draw:NO
To_Move:+
BEGIN Time
Time_Unit:1sec
Total_Time:#{@total_time}
Byoyomi:#{@byoyomi}
Least_Time_Per_Move:#{Least_Time_Per_Move}
END Time
BEGIN Position
Jishogi_Declaration:1.1
P1-KY-KE-GI-KI-OU-KI-GI-KE-KY
P2 * -HI *  *  *  *  * -KA * 
P3-FU-FU-FU-FU-FU-FU-FU-FU-FU
P4 *  *  *  *  *  *  *  *  * 
P5 *  *  *  *  *  *  *  *  * 
P6 *  *  *  *  *  *  *  *  * 
P7+FU+FU+FU+FU+FU+FU+FU+FU+FU
P8 * +KA *  *  *  *  * +HI * 
P9+KY+KE+GI+KI+OU+KI+GI+KE+KY
P+
P-
+
END Position
END Game_Summary
EOM
    return str
  end
end

def usage
    print <<EOM
NAME
	shogi-server - server for CSA server protocol

SYNOPSIS
	shogi-server event_name port_number

DESCRIPTION
	server for CSA server protocol

OPTIONS
	--pid-file file
		specify filename for logging process ID

LICENSE
	this file is distributed under GPL version2 and might be compiled by Exerb

SEE ALSO

RELEASE
	#{Release}

REVISION
	#{Revision}
EOM
end

def log_message(str)
  printf("%s message: %s\n", Time::new.to_s, str)
end

def log_warning(str)
  printf("%s warning: %s\n", Time::new.to_s, str)
end

def log_error(str)
  printf("%s error: %s\n", Time::new.to_s, str)
end


def parse_command_line
  options = Hash::new
  parser = GetoptLong.new
  parser.ordering = GetoptLong::REQUIRE_ORDER
  parser.set_options(
                     ["--pid-file", GetoptLong::REQUIRED_ARGUMENT])

  parser.quiet = true
  begin
    parser.each_option do |name, arg|
      name.sub!(/^--/, '')
      options[name] = arg.dup
    end
  rescue
    usage
    raise parser.error_message
  end
  return options
end

def good_game_name?(str)
  if ((str =~ /^(.+):\d+:\d+$/) &&
      (good_identifier?($1)))
    return true
  else
    return false
  end
end

def good_identifier?(str)
  if ((str =~ /\A[\w\d_@\-\.]+\z/) &&
      (str.length < Max_Identifier_Length))
    return true
  else
    return false
  end
end

def good_login?(str)
  tokens = str.split
  if (((tokens.length == 3) || ((tokens.length == 4) && tokens[3] == "x1")) &&
      (tokens[0] == "LOGIN") &&
      (good_identifier?(tokens[1])))
    return true
  else
    return false
  end
end

def  write_pid_file(file)
  open(file, "w") do |fh|
    fh.print Process::pid, "\n"
  end
end

def mutex_watchdog(mutex, sec)
  while true
    begin
      timeout(sec) do
        mutex.lock
        mutex.unlock
      end
      sleep(sec)
    rescue TimeoutError
      log_error("mutex watchdog timeout")
      exit(1)
    end
  end
end

def main
  $mutex = Mutex::new
  Thread::start do
    mutex_watchdog($mutex, 10)
  end

  $options = parse_command_line
  if (ARGV.length != 2)
    usage
    exit 2
  end

  LEAGUE.event = ARGV.shift
  port = ARGV.shift

  write_pid_file($options["pid-file"]) if ($options["pid-file"])


  Thread.abort_on_exception = true

  server = TCPserver.open(port)
  log_message("server started")

  while true
    Thread::start(server.accept) do |client|
      client.sync = true
      player = nil
      while (str = client.gets_timeout(Login_Time))
        begin
          $mutex.lock
          str =~ /([\r\n]*)$/
          eol = $1
          if (good_login?(str))
            player = Player::new(str, client)
            if (LEAGUE.players[player.name])
              if ((LEAGUE.players[player.name].password == player.password) &&
                  (LEAGUE.players[player.name].status != "game"))
                log_message(sprintf("user %s login forcely", player.name))
                LEAGUE.players[player.name].kill
              else
                client.write_safe("LOGIN:incorrect" + eol)
                client.write_safe(sprintf("username %s is already connected%s", player.name, eol)) if (str.split.length >= 4)
                client.close
                Thread::exit
              end
            end
            LEAGUE.add(player)
            break
          else
            client.write_safe("LOGIN:incorrect" + eol)
            client.write_safe("type 'LOGIN name password' or 'LOGIN name password x1'" + eol) if (str.split.length >= 4)
          end
        ensure
          $mutex.unlock
        end
      end                       # login loop
      if (! player)
        client.close
        Thread::exit
      end
      log_message(sprintf("user %s login", player.name))
      player.run
      begin
        $mutex.lock
        if (player.game)
          player.game.kill(player)
        end
        player.finish
        LEAGUE.delete(player)
        log_message(sprintf("user %s logout", player.name))
      ensure
        $mutex.unlock
      end
    end
  end
end

if ($0 == __FILE__)
  LEAGUE = League::new
  main
end
