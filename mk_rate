#!/usr/bin/ruby
## $Id$

## Copyright (C) 2006 Daigo Moriwaki <daigo at debian dot org>
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#
# This calculates rating scores of every players from CSA files, and outputs a
# yaml file (players.yaml) that Shogi Server can read.
#
# Sample:
#   $ ./mk_rate . > players.yaml
#
# The conditions that games and players are rated as following:
#   * Rated games, which were played by both rated players.
#   * Rated players, who logged in the server with a name followed by a trip:
#     "name,trip".
#   * (Rated) players, who played more than $GAMES_LIMIT [ten] (rated) games. 
#
#
# PREREQUIRE
# ==========
#
#   Ruby bindings for the GNU Scientific Library (GSL) is required.
#   You can download it from  http://rb-gsl.rubyforge.org/
#   Or, if you use Debian, 
#     $ sudo aptitude install libgsl-ruby1.8
#

require 'yaml'
require 'time'
require 'gsl'

#################################################
# Constants
#

# Count out players who play less games than $GAMES_LIMIT
$GAMES_LIMIT = $DEBUG ? 0 : 10
WIN_MARK  = "win"
LOSS_MARK = "lose"

# Holds players
$players = Hash.new
# Holds the last time when a player gamed
$players_time = Hash.new { Time.at(0) }


#################################################
# Keeps the value of the lowest key
#
class Record
  def initialize
    @lowest = []
  end

  def set(key, value)
    if @lowest.empty? || key < @lowest[0]
      @lowest = [key, value]
    end
  end

  def get
    if @lowest.empty?
      nil
    else
      @lowest[1]
    end
  end
end

#################################################
# Calculates rates of every player from a Win Loss GSL::Matrix
#
class Rating
  include Math

  # The model of the win possibility is 1/(1 + 10^(-d/400)).
  # The equation in this class is 1/(1 + e^(-Kd)).
  # So, K should be calculated like this.
  K = Math.log(10.0) / 400.0
  
  # Convergence limit to stop Newton method.
  ERROR_LIMIT = 1.0e-3
  # Stop Newton method after this iterations.
  COUNT_MAX = 500

  # Average rate among the players
  AVERAGE_RATE = 1000

  
  ###############
  # Class methods
  #  
  
  ##
  # Calcurates the average of the vector.
  #
  def Rating.average(vector, mean=0.0)
    sum = Array(vector).inject(0.0) {|sum, n| sum + n}
    vector -= GSL::Vector[*Array.new(vector.size, sum/vector.size - mean)]
    vector
  end

  ##################
  # Instance methods
  #
  def initialize(win_loss_matrix)
    @record = Record.new
    @n = win_loss_matrix
    case @n
    when GSL::Matrix
      @size = @n.size1
    when ::Matrix
      @size = @n.row_size
    else
      raise ArgumentError
    end
    initial_rate
  end
  attr_reader :rate, :n

  def player_vector
    GSL::Vector[*
      (0...@size).collect {|k| yield k}
    ]
  end

  def each_player
    (0...@size).each {|k| yield k}
  end

  ##
  # The possibility that the player k will beet the player i.
  #
  def win_rate(k,i)
    1.0/(1.0 + exp(@rate[i]-@rate[k]))
  end

  ##
  # Most possible equation
  #
  def func_vector
    player_vector do|k| 
      sum = 0.0
      each_player do |i|
        next if i == k
        sum += @n[k,i] * win_rate(i,k) - @n[i,k] * win_rate(k,i) 
      end
      sum * 2.0
    end
  end

  ##
  #           / f0/R0 f0/R1 f0/R2 ... \
  # dfk/dRj = | f1/R0 f1/R1 f1/R2 ... |
  #           \ f2/R0 f2/R1 f2/R2 ... /
  def d_func(k,j)
    sum = 0.0
    if k == j
      each_player do |i|
        next if i == k
        sum += win_rate(i,k) * win_rate(k,i) * (@n[k,i] + @n[i,k])
      end
      sum *= -2.0
    else # k != j
      sum = 2.0 * win_rate(j,k) * win_rate(k,j) * (@n[k,j] + @n[j,k])
    end
    sum
  end

  ##
  # Jacobi matrix of the func().
  #   m00 m01
  #   m10 m11
  #
  def j_matrix
    GSL::Matrix[*
      (0...@size).collect do |k|
        (0...@size).collect do |j|
          d_func(k,j)
        end
      end
    ]
  end

  ##
  # The initial value of the rate, which is of very importance for Newton method.
  # This is based on my huristics; the higher the win probablity of a player is, 
  # the greater points he takes.
  #
  def initial_rate
    possibility = 
      player_vector do |k|
        v = GSL::Vector[0, 0]
        each_player do |i|
          next if k == i
          v += GSL::Vector[@n[k,i], @n[i,k]]
        end
        v.nrm2 < 1 ? 0 : v[0] / (v[0] + v[1])
      end
    rank = possibility.sort_index
    @rate = player_vector do |k|
      K*500 * (rank[k]+1) / @size
    end
    average!
  end

  ##
  # Resets @rate as the higher the current win probablity of a player is, 
  # the greater points he takes. 
  #
  def initial_rate2
    @rate = @record.get || @rate
    rank = @rate.sort_index
    @rate = player_vector do |k|
      K*@count*1.5 * (rank[k]+1) / @size
    end
    average!
  end

  # mu is the deaccelrating parameter in Deaccelerated Newton method
  def deaccelrate(mu, old_rate, a, old_f_nrm2)
    @rate = old_rate - a * mu
    if func_vector.nrm2 < (1 - mu / 4.0 ) * old_f_nrm2 then
      return
    end
    if mu < 1e-4
      @record.set(func_vector.nrm2, @rate)
      initial_rate2
      return
    end
    $stderr.puts "mu: %f " % [mu] if $DEBUG
    deaccelrate(mu*0.5, old_rate, a, old_f_nrm2)
  end

  ##
  # Main process to calculate ratings.
  #
  def rating
    # Counter to stop the process. 
    # Calulation in Newton method may fall in an infinite loop
    @count = 0

    # Main loop
    begin
      # Solve the equation: 
      #   J*a=f
      #   @rate_(n+1) = @rate_(n) - a
      #
      # f.nrm2 should approach to zero.
      f = func_vector
      j = j_matrix

      # $stderr.puts "j: %s" % [j.inspect] if $DEBUG
      $stderr.puts "f: %s -> %f" % [f.to_a.inspect, f.nrm2] if $DEBUG

      # GSL::Linalg::LU.solve or GSL::Linalg::HH.solve would be available instead.
      a = GSL::Linalg::SV.solve(j, f)
      a = self.class.average(a)
      # $stderr.puts "a: %s -> %f" % [a.to_a.inspect, a.nrm2] if $DEBUG
      
      # Deaccelerated Newton method
      # GSL::Vector object should be immutable.
      old_rate   = @rate
      old_f      = f
      old_f_nrm2 = old_f.nrm2
      deaccelrate(1.0, old_rate, a, old_f_nrm2)
      @record.set(func_vector.nrm2, @rate)

      $stderr.printf "|error| : %5.2e\n", a.nrm2 if $DEBUG

      @count += 1
      if @count > COUNT_MAX
        $stderr.puts "Values seem to oscillate. Stopped the process."
        $stderr.puts "f: %s -> %f" % [func_vector.to_a.inspect, func_vector.nrm2]
        break
      end

    end while (a.nrm2 > ERROR_LIMIT * @rate.nrm2)
    
    @rate = @record.get
    $stderr.puts "resolved f: %s -> %f" %
      [func_vector.to_a.inspect, func_vector.nrm2] if $DEBUG

    @rate *= 1.0/K
    finite!
    self
  end

  ##
  # Make the values of @rate finite.
  #
  def finite!
    @rate = @rate.collect do |a|
      if a.infinite?
        a.infinite? * AVERAGE_RATE * 100
      else
        a
      end
    end
  end

  ##
  # Flatten the values of @rate.
  #
  def average!(mean=0.0)
    @rate = self.class.average(@rate, mean)
  end

  ##
  # Make the values of @rate integer.
  #
  def integer!
    @rate = @rate.collect do |a|
      if a.finite?
        a.to_i
      elsif a.nan?
        0
      elsif a.infinite?
        a.infinite? * AVERAGE_RATE * 100
      end
    end
  end
end



#################################################
# Main methods
#

def mk_win_loss_matrix(players)
  keys = players.keys.sort.reject do |k|
    players[k].values.inject(0) {|sum, v| sum + v[0] + v[1]} < $GAMES_LIMIT
  end

  size = keys.size

  matrix =
    GSL::Matrix[*
    ((0...size).collect do |k|
    ((0...size).collect do |j|
      if k == j
        0
      else
        v = players[keys[k]][keys[j]]
        v[0]
      end
    end)
    end)]
  
  return matrix, keys
end

def _add_win_loss(winner, loser)
  $players[winner] ||= Hash.new { GSL::Vector[0,0] }
  $players[loser]  ||= Hash.new { GSL::Vector[0,0] }
  $players[winner][loser] += GSL::Vector[1,0]
  $players[loser][winner] += GSL::Vector[0,1]
end

def _add_time(player, time)
  $players_time[player] = time if $players_time[player] < time
end

def add(black_mark, black_name, white_name, white_mark, time)
  if black_mark == WIN_MARK && white_mark == LOSS_MARK
    _add_win_loss(black_name, white_name)
  elsif black_mark == LOSS_MARK && white_mark == WIN_MARK
    _add_win_loss(white_name, black_name)
  else
    raise "Never reached!"
  end
  _add_time(black_name, time)
  _add_time(white_name, time)
end

def grep(file)
  str = File.open(file).read

  if /^N\+(.*)$/ =~ str then black_name = $1.strip end
  if /^N\-(.*)$/ =~ str then white_name = $1.strip end

  if /^'summary:(.*)$/ =~ str
    dummy, p1, p2 = $1.split(":").map {|a| a.strip}    
    p1_name, p1_mark = p1.split(" ")
    p2_name, p2_mark = p2.split(" ")
    if p1_name == black_name
      black_name, black_mark = p1_name, p1_mark
      white_name, white_mark = p2_name, p2_mark
    elsif p2_name == black_name
      black_name, black_mark = p2_name, p2_mark
      white_name, white_mark = p1_name, p1_mark
    else
      raise "Never reach!: #{black} #{white} #{p1} #{p2}"
    end
  end
  if /^'\$END_TIME:(.*)$/ =~ str
    time = Time.parse($1.strip)
  end
  if /^'rating:(.*)$/ =~ str
    black_id, white_id = $1.split(":").map {|a| a.strip}
    add(black_mark, black_id, white_id, white_mark, time)
  end
end

def usage
  $stderr.puts <<-EOF
USAGE: #{$0} dir [...]
  EOF
  exit 1
end

def main
  usage if ARGV.empty?
  while dir = ARGV.shift do
    Dir.glob( File.join(dir, "**", "*.csa") ) {|f| grep(f)}
  end

  win_loss_matrix, keys = mk_win_loss_matrix($players)
  $stderr.puts keys.inspect if $DEBUG
  $stderr.puts win_loss_matrix.inspect if $DEBUG
  rating = Rating.new(win_loss_matrix)
  rating.rating
  rating.average!(Rating::AVERAGE_RATE)
  rating.integer!

  yaml = {}
  keys.each_with_index do |p, i| # player_id, index#
    win_loss = $players[p].values.inject(GSL::Vector[0,0]) {|sum, v| sum + v}
    win = win_loss_matrix
    yaml[p] = 
      { 'name' => p.split("+")[0],
        'rate' => rating.rate[i],
        'last_modified' => $players_time[p].dup,
        'win'  => win_loss[0],
        'loss' => win_loss[1]}
  end
  puts yaml.to_yaml
end

if __FILE__ == $0
  main
end

# vim: ts=2 sw=2 sts=0
