#!/usr/bin/ruby
## $Id$

## Copyright (C) 2006 Daigo Moriwaki <daigo at debian dot org>
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#
# This calculates rating scores of every players from CSA files, and outputs a
# yaml file (players.yaml) that Shogi Server can read.
#
# Sample:
#   $ ./mk_rate . > players.yaml
#
# The conditions that games and players are rated as following:
#   * Rated games, which were played by both rated players.
#   * Rated players, who logged in the server with a name followed by a trip:
#     "name,trip".
#   * (Rated) players, who played more than $GAMES_LIMIT [ten] (rated) games. 
#

require 'yaml'
require 'time'
require 'gsl'

#################################################
# Constants
#
$GAMES_LIMIT = $DEBUG ? 0 : 10
WIN_MARK  = "win"
LOSS_MARK = "lose"

$players = Hash.new
$players_time = Hash.new { Time.at(0) }


#################################################
# Calculates rates of every player from a Win Loss GSL::Matrix
#
class Rating
  include Math

  # The model of the win possibility is 1/(1 + 10^(-d/400))
  # The equation in this class is 1/(1 + e^(-Kd))
  # So, K should be like this.
  K = Math.log(10.0) / 400.0
  
  # Convergence limit to stop Newton method.
  ERROR_LIMIT = 1.0e-3

  # Average rate among the players
  AVERAGE_RATE = 1000
  
  ###############
  # Class methods
  #
  def Rating.average(vector, mean=0.0)
    sum = Array(vector).inject(0.0) {|sum, n| sum + n}
    vector -= GSL::Vector[*Array.new(vector.size, sum/vector.size - mean)]
    vector
  end

  ##################
  # Instance methods
  #
  def initialize(win_loss_matrix)
    @n = win_loss_matrix
    case @n
    when GSL::Matrix
      @size = @n.size1
    when ::Matrix
      @size = @n.row_size
    else
      raise ArgumentError
    end
    # 0 is the initial value
    @rate = initial_rate
  end
  attr_reader :rate, :n

  def player_vector
    GSL::Vector[*
      (0...@size).collect {|k| yield k}
    ]
  end

  def each_player
    (0...@size).each {|k| yield k}
  end

  ##
  # The possibility that the player k will beet the player i.
  #
  def win_rate(k,i)
    1.0/(1.0 + exp(@rate[i]-@rate[k]))
  end

  ##
  # Most possible equation
  #
  def func_vector
    player_vector do|k| 
      sum = 0.0
      each_player do |i|
        next if i == k
        sum += @n[k,i] * win_rate(i,k) - @n[i,k] * win_rate(k,i) 
      end
      sum * 2.0
    end
  end

  ##
  #         / f0/R0 f0/R1 f0/R2 ... \
  # fk/Rj = | f1/R0 f1/R1 f1/R2 ... |
  #         \ f2/R0 f2/R1 f2/R2 ... /
  def d_funk(k,j)
    sum = 0.0
    if k == j
      each_player do |i|
        next if i == k
        sum += win_rate(i,k) * win_rate(k,i) * (@n[k,i] + @n[i,k])
        sum *= -2.0
      end
    else # k != j
      sum = win_rate(j,k) * win_rate(k,j) * (@n[k,j] + @n[j,k])
      sum *= 2.0
    end
    sum
  end

  ##
  # Jacobi matrix of the func().
  #   m00 m01
  #   m10 m11
  #
  def j_matrix
    GSL::Matrix[*
      (0...@size).collect do |k|
        (0...@size).collect do |j|
          d_funk(k,j)
        end
      end
    ]
  end

  ##
  # The initial value of the rate, which is of very importance for Newton method.
  # This is based on my huristics. 
  #
  def initial_rate
    possibility = 
      player_vector do |k|
        v = GSL::Vector[0.0, 0.0]
        each_player do |i|
          next if k == i
          v += GSL::Vector[@n[k,i], @n[i,k]]
        end
        v[0] + v[1] == 0 ? 0.001 : v[0] / (v[0] + v[1])
      end
    rank = possibility.sort_index
    player_vector do |k|
      K*500 * (rank[k]+1) / (@size)
    end
  end

  ##
  # Main method to calculate ratings.
  #
  def rating
    # Counter to stop the process. 
    # Calulation in Newton method may fall in an infinite loop
    count = 0
    # Mu parameter in Deaccelerated Newton method
    mu = 1

    # Main loop
    begin
      # Solve the equation: 
      #   J*a=f
      #   @rate_(n+1) = @rate_(n) - a
      f = func_vector
      j = j_matrix

      # f.nrm2 should approach to zero.
      $stderr.puts "f: %s -> %f" % [f.to_a.inspect, f.nrm2] if $DEBUG

      # LU is not available because J may not be a normal matrix.
      # a = GSL::Linalg::LU.solve(j, f)
      a = GSL::Linalg::SV.solve(j, f)
      a = self.class.average(a)
      
      # Deaccelerated Newton method
      if mu == 1
        old_rate = GSL::Vector.alloc(@rate)
        old_f    = GSL::Vector.alloc(f)
        @rate = old_rate - a * mu
      end
      if func_vector.nrm2 < (1.0 - mu / 4.0) * old_f.nrm2
        mu = 1
        break
      else
        mu *= 0.5
        @rate = old_rate - a * mu
      end

      $stderr.printf "|error| : %5.2e\n", a.nrm2 if $DEBUG

      count += 1
      if count > 300
        $stderr.puts "Values seem to oscillate. Stopped the process."
        $stderr.puts "f: %s -> %f" % [f.to_a.inspect, f.nrm2]
        break
      end

    end while (a.nrm2 > ERROR_LIMIT * @rate.nrm2)
    #end while ( !(0..0.01).include?(func_vector.nrm2) )
    
    $stderr.puts "resolved f: %s -> %f" %
      [func_vector.to_a.inspect, func_vector.nrm2] if $DEBUG

    @rate *= 1.0/K
    finite!
    self
  end

  def finite!
    @rate = @rate.collect do |a|
      if a.infinite?
        a.infinite? * AVERAGE_RATE * 100
      else
        a
      end
    end
  end

  def average!(mean=0.0)
    @rate = self.class.average(@rate, mean)
  end

  def integer!
    @rate = @rate.collect do |a|
      if a.finite?
        a.to_i
      elsif a.nan?
        0
      elsif a.infinite?
        a.infinite? * AVERAGE_RATE * 100
      end
    end
  end
end



#################################################
# Main methods
#

def mk_win_loss_matrix(players)
  keys = players.keys.sort.reject do |k|
    players[k].values.inject(0) {|sum, v| sum + v[0] + v[1]} < $GAMES_LIMIT
  end

  size = keys.size

  matrix =
    GSL::Matrix[*
    ((0...size).collect do |k|
    ((0...size).collect do |j|
      if k == j
        0
      else
        v = players[keys[k]][keys[j]]
        v[0]
      end
    end)
    end)]
  
  return matrix, keys
end

def _add_win_loss(winner, loser)
  $players[winner] ||= Hash.new { GSL::Vector[0,0] }
  $players[loser]  ||= Hash.new { GSL::Vector[0,0] }
  $players[winner][loser] += GSL::Vector[1,0]
  $players[loser][winner] += GSL::Vector[0,1]
end

def _add_time(player, time)
  $players_time[player] = time if $players_time[player] < time
end

def add(black_mark, black_name, white_name, white_mark, time)
  if black_mark == WIN_MARK && white_mark == LOSS_MARK
    _add_win_loss(black_name, white_name)
  elsif black_mark == LOSS_MARK && white_mark == WIN_MARK
    _add_win_loss(white_name, black_name)
  else
    raise "Never reached!"
  end
  _add_time(black_name, time)
  _add_time(white_name, time)
end

def grep(file)
  str = File.open(file).read

  if /^N\+(.*)$/ =~ str then black_name = $1.strip end
  if /^N\-(.*)$/ =~ str then white_name = $1.strip end

  if /^'summary:(.*)$/ =~ str
    dummy, p1, p2 = $1.split(":").map {|a| a.strip}    
    p1_name, p1_mark = p1.split(" ")
    p2_name, p2_mark = p2.split(" ")
    if p1_name == black_name
      black_name, black_mark = p1_name, p1_mark
      white_name, white_mark = p2_name, p2_mark
    elsif p2_name == black_name
      black_name, black_mark = p2_name, p2_mark
      white_name, white_mark = p1_name, p1_mark
    else
      raise "Never reach!: #{black} #{white} #{p1} #{p2}"
    end
  end
  if /^'\$END_TIME:(.*)$/ =~ str
    time = Time.parse($1.strip)
  end
  if /^'rating:(.*)$/ =~ str
    black_id, white_id = $1.split(":").map {|a| a.strip}
    add(black_mark, black_id, white_id, white_mark, time)
  end
end

def usage
  $stderr.puts <<-EOF
USAGE: #{$0} dir [...]
  EOF
  exit 1
end

def main
  usage if ARGV.empty?
  while dir = ARGV.shift do
    Dir.glob( File.join(dir, "**", "*.csa") ) {|f| grep(f)}
  end

  win_loss_matrix, keys = mk_win_loss_matrix($players)
  $stderr.puts keys.inspect if $DEBUG
  $stderr.puts win_loss_matrix.inspect if $DEBUG
  rating = Rating.new(win_loss_matrix)
  rating.rating
  rating.average!(Rating::AVERAGE_RATE)
  rating.integer!

  yaml = {}
  keys.each_with_index do |p, i| # player_id, index#
    win_loss = $players[p].values.inject(GSL::Vector[0,0]) {|sum, v| sum + v}
    win = win_loss_matrix
    yaml[p] = 
      { 'name' => p.split("+")[0],
        'rate' => rating.rate[i],
        'last_modified' => $players_time[p].dup,
        'win'  => win_loss[0],
        'loss' => win_loss[1]}
  end
  puts yaml.to_yaml
end

if __FILE__ == $0
  main
end

# vim: ts=2 sw=2 sts=0
